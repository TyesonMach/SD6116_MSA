# Single pipeline: build+push (CI) then deploy (CD) on every commit to main or manual run.
trigger:
  branches:
    include: [ main ]

pr:
  branches:
    include: [ main ]

pool:
  vmImage: 'ubuntu-latest'

variables:
  # Service connections you created above
  dockerRegistryServiceConnection: 'acr-conn'
  kubernetesServiceConnection: 'aks-conn'

  # Your ACR and image repositories
  containerRegistry: 'acrdevopssd6116.azurecr.io'
  backendImageName:  'backend'
  frontendImageName: 'frontend'

  # Target namespace in AKS (make sure it exists, or we create it in Deploy stage)
  namespace: 'dev'

stages:
- stage: BuildAndPush
  displayName: Build & Push Docker Images
  jobs:
  - job: BuildPush
    steps:
    - checkout: self

    # Compute a unique tag: <branch>-<buildId>-<shortSha>
    - bash: |
        SHORT_SHA=$(echo "$(Build.SourceVersion)" | cut -c1-7)
        TAG="$(Build.SourceBranchName)-$(Build.BuildId)-$SHORT_SHA"
        echo "##vso[task.setvariable variable=TAG]$TAG"
        echo "TAG=$TAG"
      displayName: Compute image tag

    # Detect whether frontend Dockerfile is valid (it currently contains a literal "..." line)
    - bash: |
        if grep -qx '\.\.\.' src/frontend/Dockerfile; then
          echo "Frontend Dockerfile contains '...' placeholder. Skipping FE build."
          echo "##vso[task.setvariable variable=BuildFrontend]false"
        else
          echo "##vso[task.setvariable variable=BuildFrontend]true"
        fi
      displayName: Check frontend Dockerfile

    # Login (auth also occurs in Docker@2, but this makes logs clearer)
    - task: Docker@2
      displayName: Login to ACR
      inputs:
        command: login
        containerRegistry: $(dockerRegistryServiceConnection)

    # --- Build images ---
    - task: Docker@2
      displayName: Build backend image
      inputs:
        command: build
        containerRegistry: $(dockerRegistryServiceConnection)
        repository: $(backendImageName)
        Dockerfile: src/backend/Dockerfile
        buildContext: src/backend
        tags: |
          $(TAG)

    - task: Docker@2
      condition: eq(variables['BuildFrontend'], 'true')
      displayName: Build frontend image
      inputs:
        command: build
        containerRegistry: $(dockerRegistryServiceConnection)
        repository: $(frontendImageName)
        Dockerfile: src/frontend/Dockerfile
        buildContext: src/frontend
        tags: |
          $(TAG)

    # --- (Optional) Security scan example (commented) ---
    # - script: docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy:latest image --no-progress --severity HIGH,CRITICAL --exit-code 1 $(backendImageName):$(TAG)
    #   displayName: Scan backend image (Trivy)
    # - script: docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy:latest image --no-progress --severity HIGH,CRITICAL --exit-code 1 $(frontendImageName):$(TAG)
    #   condition: eq(variables['BuildFrontend'], 'true')
    #   displayName: Scan frontend image (Trivy)

    # --- Push images ---
    - task: Docker@2
      displayName: Push backend image
      inputs:
        command: push
        containerRegistry: $(dockerRegistryServiceConnection)
        repository: $(backendImageName)
        tags: |
          $(TAG)

    - task: Docker@2
      condition: eq(variables['BuildFrontend'], 'true')
      displayName: Push frontend image
      inputs:
        command: push
        containerRegistry: $(dockerRegistryServiceConnection)
        repository: $(frontendImageName)
        tags: |
          $(TAG)

    # --- Inject the computed tags into manifests under ./azure ---
    # Uses placeholders if present; otherwise replaces the first "image:" line in each file.
    - bash: |
        set -euo pipefail

        # Read pipeline variable into a shell var
        BF="$(BuildFrontend)"

        BE_IMG="$(containerRegistry)/$(backendImageName):$(TAG)"
        FE_IMG="$(containerRegistry)/$(frontendImageName):$(TAG)"

        echo "Backend image:  $BE_IMG"
        echo "Frontend image: $FE_IMG"

        mkdir -p out
        cp -r azure/* out/

        # Patch backend.yaml safely (no sed). NOTE: --local + -f ONLY (no resource name)
        kubectl set image -f out/backend.yaml \
          backend="$BE_IMG" \
          --local -o yaml > out/backend.patched.yaml
        mv out/backend.patched.yaml out/backend.yaml

        # Patch frontend only when you build FE and file exists
        if [ "${BF:-false}" = "true" ] && [ -f out/frontend.yaml ]; then
          kubectl set image -f out/frontend.yaml \
            frontend="$FE_IMG" \
            --local -o yaml > out/frontend.patched.yaml
          mv out/frontend.patched.yaml out/frontend.yaml
        fi

        echo "----- backend.yaml (after patch) -----"
        nl -ba out/backend.yaml | sed -n '1,200p'

        # Client-side validation before shipping to Deploy stage
        kubectl apply --dry-run=client -n $(namespace) -f out/backend.yaml
        if [ -f out/frontend.yaml ]; then
          kubectl apply --dry-run=client -n $(namespace) -f out/frontend.yaml || true
        fi
      displayName: Patch manifests with kubectl 

    # Publish updated manifests for the Deploy stage
    - publish: out
      artifact: manifests

- stage: Deploy
  displayName: Deploy to AKS
  dependsOn: BuildAndPush
  jobs:
  - job: DeployJob
    steps:
    - checkout: none

    # Bring the mutated manifests produced in the previous stage
    - download: current
      artifact: manifests
      displayName: Download manifests

    # Ensure namespace exists (idempotent)
    - task: Kubernetes@1
      displayName: Ensure namespace
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        command: apply
        useConfigurationFile: true
        configurationType: inline
        inline: |
          apiVersion: v1
          kind: Namespace
          metadata:
            name: $(namespace)

    # Apply MongoDB (optional for your appâ€”adjust as needed)
    - task: Kubernetes@1
      displayName: Apply mongodb.yaml
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: apply
        useConfigurationFile: true
        configuration: $(Pipeline.Workspace)/manifests/mongodb.yaml

    # Apply backend
    - task: Kubernetes@1
      displayName: Apply backend.yaml
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: apply
        useConfigurationFile: true
        configuration: $(Pipeline.Workspace)/manifests/backend.yaml

    # Apply frontend (only if FE build was enabled)
    - task: Kubernetes@1
      condition: eq(variables['BuildFrontend'], 'true')
      displayName: Apply frontend.yaml
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: apply
        useConfigurationFile: true
        configuration: $(Pipeline.Workspace)/manifests/frontend.yaml

    # Apply ingress (requires an ingress controller like ingress-nginx installed on AKS)
    - task: Kubernetes@1
      displayName: Apply ingress.yml
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: apply
        useConfigurationFile: true
        configuration: $(Pipeline.Workspace)/manifests/ingress.yml
