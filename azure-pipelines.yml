# Single pipeline: build+push (CI) then deploy (CD) on every commit to main or manual run.
trigger:
  branches:
    include: [ main ]

pr:
  branches:
    include: [ main ]

pool:
  vmImage: 'ubuntu-latest'

variables:
  # Service connections you created above
  dockerRegistryServiceConnection: 'acr-conn'
  kubernetesServiceConnection: 'aks-conn'

  # Your ACR and image repositories
  containerRegistry: 'acrdevopssd6116.azurecr.io'
  backendImageName:  'backend'
  frontendImageName: 'frontend'

  # Target namespace in AKS (make sure it exists, or we create it in Deploy stage)
  namespace: 'dev'

stages:
- stage: BuildAndPush
  displayName: Build & Push Docker Images
  jobs:
  - job: BuildPush
    steps:
    - checkout: self

    # Compute a unique tag: <branch>-<buildId>-<shortSha>
    - bash: |
        SHORT_SHA=$(echo "$(Build.SourceVersion)" | cut -c1-7)
        TAG="$(Build.SourceBranchName)-$(Build.BuildId)-$SHORT_SHA"
        echo "##vso[task.setvariable variable=TAG]$TAG"
        echo "TAG=$TAG"
      displayName: Compute image tag

    # Detect whether frontend Dockerfile is valid (it currently contains a literal "..." line)
    - bash: |
        if grep -qx '\.\.\.' src/frontend/Dockerfile; then
          echo "Frontend Dockerfile contains '...' placeholder. Skipping FE build."
          echo "##vso[task.setvariable variable=BuildFrontend]false"
        else
          echo "##vso[task.setvariable variable=BuildFrontend]true"
        fi
      displayName: Check frontend Dockerfile

    # Login (auth also occurs in Docker@2, but this makes logs clearer)
    - task: Docker@2
      displayName: Login to ACR
      inputs:
        command: login
        containerRegistry: $(dockerRegistryServiceConnection)

    # --- Build images ---
    - task: Docker@2
      displayName: Build backend image
      inputs:
        command: build
        containerRegistry: $(dockerRegistryServiceConnection)
        repository: $(backendImageName)
        Dockerfile: src/backend/Dockerfile
        buildContext: src/backend
        tags: |
          $(TAG)

    - task: Docker@2
      condition: eq(variables['BuildFrontend'], 'true')
      displayName: Build frontend image
      inputs:
        command: build
        containerRegistry: $(dockerRegistryServiceConnection)
        repository: $(frontendImageName)
        Dockerfile: src/frontend/Dockerfile
        buildContext: src/frontend
        tags: |
          $(TAG)

    # --- (Optional) Security scan example (commented) ---
    # - script: docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy:latest image --no-progress --severity HIGH,CRITICAL --exit-code 1 $(backendImageName):$(TAG)
    #   displayName: Scan backend image (Trivy)
    # - script: docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy:latest image --no-progress --severity HIGH,CRITICAL --exit-code 1 $(frontendImageName):$(TAG)
    #   condition: eq(variables['BuildFrontend'], 'true')
    #   displayName: Scan frontend image (Trivy)

    # --- Push images ---
    - task: Docker@2
      displayName: Push backend image
      inputs:
        command: push
        containerRegistry: $(dockerRegistryServiceConnection)
        repository: $(backendImageName)
        tags: |
          $(TAG)

    - task: Docker@2
      condition: eq(variables['BuildFrontend'], 'true')
      displayName: Push frontend image
      inputs:
        command: push
        containerRegistry: $(dockerRegistryServiceConnection)
        repository: $(frontendImageName)
        tags: |
          $(TAG)

    # --- Inject the computed tags into manifests under ./azure ---
    # Uses placeholders if present; otherwise replaces the first "image:" line in each file.
    - bash: |
        set -euo pipefail

        # Pull pipeline vars into env
        export BF="$(BuildFrontend)"
        export REG="$(containerRegistry)"
        export TAG="$(TAG)"

        echo "Backend image:  ${REG}/$(backendImageName):${TAG}"
        echo "Frontend image: ${REG}/$(frontendImageName):${TAG}"

        mkdir -p out
        cp -r azure/* out/

        # Build kustomization.yaml dynamically (only add files that exist)
        {
          echo "resources:"
          echo "- backend.yaml"
          if [ "${BF:-false}" = "true" ] && [ -f out/frontend.yaml ]; then echo "- frontend.yaml"; fi
          [ -f out/mongodb.yaml ] && echo "- mongodb.yaml"
          [ -f out/ingress.yml ] && echo "- ingress.yml"
          echo "images:"
          echo "- name: ${REG}/backend"
          echo "  newName: ${REG}/backend"
          echo "  newTag: ${TAG}"
          if [ "${BF:-false}" = "true" ] && [ -f out/frontend.yaml ]; then
            echo "- name: ${REG}/frontend"
            echo "  newName: ${REG}/frontend"
            echo "  newTag: ${TAG}"
          fi
        } > out/kustomization.yaml

        echo "----- kustomization.yaml -----"
        cat out/kustomization.yaml

        # Render all manifests with updated images (safe, offline)
        kubectl kustomize out > out/rendered.yaml

        echo "----- rendered.yaml (first 200 lines) -----"
        nl -ba out/rendered.yaml | sed -n '1,200p'
      displayName: Build manifests with Kustomize

    # Publish updated manifests for the Deploy stage
    - publish: out/rendered.yaml
      artifact: manifests

- stage: Deploy
  displayName: Deploy to AKS
  dependsOn: BuildAndPush
  jobs:
  - job: DeployJob
    steps:
    - checkout: none

    # Download the rendered manifest (published as artifact "manifests")
    - download: current
      artifact: manifests
      displayName: Download manifests

    # Ensure namespace exists (idempotent)
    - task: Kubernetes@1
      displayName: Ensure namespace
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        command: apply
        useConfigurationFile: true
        configurationType: inline
        inline: |
          apiVersion: v1
          kind: Namespace
          metadata:
            name: $(namespace)

    # Apply the single, Kustomize-rendered file
    - task: Kubernetes@1
      displayName: Apply rendered manifests
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: apply
        useConfigurationFile: true
        configuration: $(Pipeline.Workspace)/manifests/rendered.yaml

    # Optional: rollout checks and a quick status
    - task: Kubernetes@1
      displayName: Rollout status (backend)
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'kubectl'
        arguments: 'rollout status deploy/backend --timeout=120s'

    - task: Kubernetes@1
      condition: eq(variables['BuildFrontend'], 'true')
      displayName: Rollout status (frontend)
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'kubectl'
        arguments: 'rollout status deploy/frontend --timeout=120s'

    - task: Kubernetes@1
      displayName: Get services
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'kubectl'
        arguments: 'get pods,svc -o wide'

